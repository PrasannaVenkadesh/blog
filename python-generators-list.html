<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="https://prasannavenkadesh.github.io/blog/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="https://prasannavenkadesh.github.io/blog/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="https://prasannavenkadesh.github.io/blog/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Prasanna Venkadesh">
  <meta name="description" content="Posts and writings by Prasanna Venkadesh">

  <link href="https://prasannavenkadesh.github.io/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Towards Freedom Atom" />

<meta name="keywords" content="python">

  <title>
    Towards Freedom
&ndash; Don't Convert Generators to List at Once  </title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="https://prasannavenkadesh.github.io/blog">
        <img src="https://prasannavenkadesh.github.io/blog/images/pic.png" alt="logo">
      </a>
      <h2><a href="https://prasannavenkadesh.github.io/blog">Towards Freedom</a></h2>
      <p>Free Software + Free Culture = Freedom</p>
      <ul>
        <li><a href="https://prasannavenkadesh.github.io" target="_blank">About</a></li>
        <li><a href="https://gitlab.com/prashere" target="_blank">Code</a></li>
        <li><a href="https://manyver.se" target="_blank">SSB - Manyverse</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="https://prasannavenkadesh.github.io/blog">Index</a> &brvbar; <a href="https://prasannavenkadesh.github.io/blog/archives.html">Archives</a>
      &brvbar; <a href="https://prasannavenkadesh.github.io/blog/feeds/all.atom.xml">Atom</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h1><a href="https://prasannavenkadesh.github.io/blog/python-generators-list.html">Don't Convert Generators to List at Once</a></h1>
  </div>
  <div class="article_meta">
    <p>Posted on: Sun 12 July 2020</p>
  </div>
  <div class="article_text">
    <p><strong>TL;DR: Convert the generator into list, if and only if the dataset is small, else consume on demand or rethink your design.</strong></p>
<p>Python has a special function called <code>Generators</code> which <code>yields</code> value as we request from it rather than dumping everything into the memory at once. For example think about huge dataset like a list of lakh or crore number of elements. This is where generators comes in. Instead of creating all the elements at once and occupying system's memory, generators generate the values required as we request from it a.k.a <strong>lazy iterator</strong>.</p>
<p>Recently I came across a code like this.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">netaddr</span> <span class="kn">import</span> <span class="n">IPNetwork</span>

<span class="n">cidr</span> <span class="o">=</span> <span class="s1">&#39;10.0.0.0/8&#39;</span>
<span class="n">subnet_length</span> <span class="o">=</span> <span class="mi">32</span>

<span class="n">network</span> <span class="o">=</span> <span class="n">IPNetwork</span><span class="p">(</span><span class="s1">&#39;10.0.0.0/8&#39;</span><span class="p">)</span>
<span class="n">ip_addresses</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">subnet</span><span class="p">(</span><span class="n">subnet_length</span><span class="p">))</span>
<span class="n">no_of_hosts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ip_addresses</span><span class="p">)</span>
</pre></div>


<p><code>netaddr</code> is a python library which helps developers to play around with network addresses. In the above snippet, a class A network with network length of 8 and a subnet length of 32 is provided. The intention of the developer is to have all possible <code>ip addresses</code> for the given IP address class and subnet length. If you know how to calculate the total number of possible <code>hosts</code> or <code>ip addresses</code> for a given subnet, then you will arrive at the value of 16777216. This is the number of ip addresses that is possible for the given subnet.</p>
<p>Clearly, the authors of netaddr understood that sometimes such a huge number of hosts might be possible and hence <code>network.subnet()</code> function is a generator function. The issue here is converting it into a list at once. It defeats the purpose of having a generator at all. By calling <code>list(network.subnet(subnet_length))</code> the program tries to dump all the values of the generator at once to convert it into a list, which in this case is going to both CPU and memory intensive.</p>
<p><img alt="screenshot on the amount of memory consumed by converting to list" src="images/memory-1.png"></p>
<p>If the intention is just to calculate the total number of possible hosts for a given subnet and IP class range, then the above is memory expensive operation as it first prepares a list of all possible addresses and then counting the length of that list. This is clear from the above screenshot of the <code>htop</code> utility which I used to measure the amount of memory the program used for doing that. 24% of memory was used to achive that and the CPU was of-course at 100% (the screenshot was taken after the list was prepared hence 0).</p>
<p>Instead, the following method can be used to minimize the memory usage.</p>
<div class="highlight"><pre><span></span><span class="nv">no_of_hosts</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nv">_</span> <span class="nv">in</span> <span class="nv">network</span>.<span class="nv">subnet</span><span class="ss">(</span><span class="mi">32</span><span class="ss">)</span>:
    <span class="nv">no_of_hosts</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>


<p>The maximum amount of memory used for this approach is only 0.6%, of-course the CPU usage remains at 100% since the program needs to produce the intended value from generator for such huge range. We just don't hold those values anywhere in our program, hence memory is not occupied for all the generated value.</p>
<p><img alt="screenshot on the amount of memory consumed by just counting the iterations and not converting to list" src="images/memory-2.png"></p>
<p>Even a far more better approach for calculating total number of hosts would be to use the formula which is just a quick arithmetic operation.</p>
<div class="highlight"><pre><span></span><span class="mf">2</span><span class="o">**</span><span class="p">(</span><span class="n">network_length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">subnet_length</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2</span><span class="w"></span>
</pre></div>


<p>This solution works if the programmers intention is just to count the number of possible hosts or length of the total values produced by the generator, else if they need to have list the list of ip addresses for other purposes, they can be consumed on the fly for a given number like how the frontend makes use of pagination to display large number of records.</p>
<p><code>generators</code> have this method called <code>send(arg)</code> for which accepts one argument. We can make use of <code>for</code> loop with <code>range</code> method to get ip addresses in batches.</p>
<div class="highlight"><pre><span></span><span class="nv">def</span> <span class="nv">get_ten_addresses</span><span class="ss">(</span><span class="nv">subnet_generator</span><span class="ss">)</span>:
    <span class="k">return</span> [<span class="nv">subnet</span>.<span class="k">send</span><span class="ss">(</span><span class="nv">None</span><span class="ss">)</span> <span class="k">for</span> <span class="nv">_</span> <span class="nv">in</span> <span class="nv">range</span><span class="ss">(</span><span class="mi">1</span>, <span class="mi">11</span><span class="ss">)</span>]

<span class="nv">subnet</span> <span class="o">=</span> <span class="nv">network</span>.<span class="nv">subnet</span><span class="ss">(</span><span class="mi">32</span><span class="ss">)</span>
<span class="nv">ten_addresses</span> <span class="o">=</span> <span class="nv">get_ten_addresses</span><span class="ss">(</span><span class="nv">subnet</span><span class="ss">)</span>
<span class="nv">next_ten_addresses</span> <span class="o">=</span> <span class="nv">get_ten_addresses</span><span class="ss">(</span><span class="nv">subnet</span><span class="ss">)</span>
</pre></div>


<p>generators know where they left and where to pick up next, so <code>ten_addresses</code> will be a list of first 10 addresses generated by the generator and <code>next_ten_addresses</code> will be as the name suggests is a list of next 10 addresses. How do we know if we have consumed all the elements of the generator? Generators will raise <code>StopIteration</code> exception to denote that.</p>
<p>If the solution depends on the entire list of values to be available, probably we need to rethink the design to store such datasets into some other disk (or) file based containers like RDBMS and retrieve it from there.</p>
  </div>
  <div class="article_meta">
    <p>Category: <a href="https://prasannavenkadesh.github.io/blog/category/programming.html">Programming</a>
 &ndash; Tags:
      <a href="https://prasannavenkadesh.github.io/blog/tag/python.html">python</a>    </p>
  </div>


</article>


    <div id="ending_message">
      <p>&copy; Prasanna Venkadesh. <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">Creative Commons</a> Attribution ShareAlike. Theme by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>.
    </div>
  </main>
</body>
</html>