<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Towards Freedom - Notes</title><link href="https://prasannavenkadesh.github.io/blog/" rel="alternate"></link><link href="https://prasannavenkadesh.github.io/blog/feeds/notes.atom.xml" rel="self"></link><id>https://prasannavenkadesh.github.io/blog/</id><updated>2022-08-12T00:00:00+05:30</updated><entry><title>Various Options To Deliver Real Time Notifications</title><link href="https://prasannavenkadesh.github.io/blog/push-notifications.html" rel="alternate"></link><published>2022-08-12T00:00:00+05:30</published><updated>2022-08-12T00:00:00+05:30</updated><author><name>Prasanna Venkadesh</name></author><id>tag:prasannavenkadesh.github.io,2022-08-12:/blog/push-notifications.html</id><summary type="html">&lt;p&gt;If you wish to deliver (or) push data from your web server to your web application running in a browser in real time, you have 4 options at the time of writing this post (2022).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Polling / Long Polling.&lt;/li&gt;
&lt;li&gt;Server Sent Events (SSE).&lt;/li&gt;
&lt;li&gt;Websockets.&lt;/li&gt;
&lt;li&gt;WebPush&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Polling&lt;/h3&gt;
&lt;p&gt;Polling and Long Polling has …&lt;/p&gt;</summary><content type="html">&lt;p&gt;If you wish to deliver (or) push data from your web server to your web application running in a browser in real time, you have 4 options at the time of writing this post (2022).&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Polling / Long Polling.&lt;/li&gt;
&lt;li&gt;Server Sent Events (SSE).&lt;/li&gt;
&lt;li&gt;Websockets.&lt;/li&gt;
&lt;li&gt;WebPush&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Polling&lt;/h3&gt;
&lt;p&gt;Polling and Long Polling has been used traditionally &amp;amp; being used till date. As the name suggests polling / long polling is not push, but clients checking (a.k.a polling) every once in a while if something has changed in the server side. For example, client making a HTTP request to server every 10 seconds as an XMLHttpRequest (XHR) or more commonly known as AJAX (Asynchronous Javascript and XML).&lt;/p&gt;
&lt;p&gt;But this is not efficient because it adds an unwanted load to the server. Imagine, 100 people using the website and each of them polling the server every 10 seconds. Even when there is no change in the server, it has to respond to every HTTP request made by the client &amp;amp; client has to keep polling.&lt;/p&gt;
&lt;h3&gt;Long Polling&lt;/h3&gt;
&lt;p&gt;Long polling is a better version of simple polling. Long polling is when client makes a HTTP request to the server and instead of immediately returning any response, the server holds the request until any data is available to send to the client. Once the data is delivered to the client, the client immediately makes another HTTP request and the cycle goes on. This approach is also called as Comet approach.&lt;/p&gt;
&lt;h3&gt;Server Sent Events&lt;/h3&gt;
&lt;p&gt;The Server Sent Events (SSE) is the first effort to push or stream data from server to the client. As usual the client makes the first request to server, the server holds the connection &amp;amp; uses some of the HTTP response headers to stream the data in the single connection, until the connection is closed by the server or client.&lt;/p&gt;
&lt;p&gt;The main difference between long polling and SSE is that in long polling when server sends the response the HTTP request-response cycle ends &amp;amp; a new connection is opened again. i.e a new connection for every message. With SSE, only one connection is opened and the server keeps pushing the data.&lt;/p&gt;
&lt;p&gt;The way it is achieved is through the &lt;em&gt;"Transfer-Encoding: chuncked"&lt;/em&gt; response header. This header informs the client that the response size is unknown and the data will be sent in chunks. This method is usually used to transfer large files from the server to client. SSE takes advantage of this and defines a message format. The message format must have &lt;em&gt;"data"&lt;/em&gt; field and optional &lt;em&gt;"event"&lt;/em&gt;, &lt;em&gt;"id"&lt;/em&gt; and &lt;em&gt;"retry"&lt;/em&gt; fields. Web browsers implement the &lt;strong&gt;EventSource javascript API&lt;/strong&gt; to initiate a SSE request to server.&lt;/p&gt;
&lt;p&gt;SSE is still HTTP request-response cycle, but everything happens within one request-response cycle. One of the main limitation, I see in SSE is the inability on the client side to set custom request headers. Lack of this ability means, one cannot pass authentication related headers as we do in usual HTTP request.&lt;/p&gt;
&lt;h3&gt;Websockets&lt;/h3&gt;
&lt;p&gt;Then came the websockets. If SSE is unidirectional (i.e servers streams events to the client), then websockets are bidirectional. Websockets is not HTTP. It is a new protocol altogether, similar to HTTP on layer 7. HTTP is used only for the initial handshake and if the server responds with an Upgrade response header, then a websocket connection is established between the client &amp;amp; the server. Web browsers implement the &lt;strong&gt;WebSocket API&lt;/strong&gt; to initiate a websocket connection from client to server.&lt;/p&gt;
&lt;p&gt;Once a websocket connection is established, each side can exchange data with each other. For pushing data from server to client, the server can ignore any message that is sent by client keep pushing the data.&lt;/p&gt;
&lt;h3&gt;WebPush&lt;/h3&gt;
&lt;p&gt;WebPush is relatively new compared to all the above. Similar to SSE, WebPush is also unidirectional. It is ideal to push notifications from server to client. The notifications are then rendered as a notification of the Desktop Environment of the OS in use. This also involves additional steps to implement compared to the above methods. WebPush can deliver notifications even when the webpage is not loaded.&lt;/p&gt;
&lt;p&gt;For WebPush, browsers are responsible to implement &lt;strong&gt;Push API&lt;/strong&gt; in browsers &amp;amp; a online service to receive push notifications from our servers. For example, a service called &lt;strong&gt;autopush&lt;/strong&gt; is used by &lt;strong&gt;Firefox&lt;/strong&gt; and &lt;strong&gt;Firebase cloud-messaging&lt;/strong&gt; is used by &lt;strong&gt;Chrome&lt;/strong&gt; derivates.&lt;/p&gt;
&lt;p&gt;On the client side, WebPush requires &lt;strong&gt;ServiceWorkers&lt;/strong&gt; which are code that runs asynchronously in the background when the browser is open &amp;amp; the ServiceWorker alone can access the &lt;strong&gt;Push API&lt;/strong&gt; to subscribe to our server.&lt;/p&gt;
&lt;p&gt;On the server side, we need to provision atleast 3 endpoints.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A GET request to get cryptographic keys from server.&lt;/li&gt;
&lt;li&gt;A POST request to subscribe for notification from client side.&lt;/li&gt;
&lt;li&gt;A POST request to publish notification to the online service run by the browser.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In short, when you use WebPush, you rely on a third party service to deliver your notification to the respective browser and for this reason, the notification messages are end-to-end encrypted with the public-key cryptography.&lt;/p&gt;
&lt;h3&gt;Final Notes&lt;/h3&gt;
&lt;p&gt;There is no one best method. One need to carefully consider which of the above methods are suitable for them based on the needs &amp;amp; the system design.&lt;/p&gt;</content><category term="Notes"></category><category term="code"></category><category term="design"></category><category term="software"></category></entry><entry><title>Notes from Clean Architecture</title><link href="https://prasannavenkadesh.github.io/blog/notes-from-clean-arch.html" rel="alternate"></link><published>2020-12-06T00:00:00+05:30</published><updated>2020-12-06T00:00:00+05:30</updated><author><name>Prasanna Venkadesh</name></author><id>tag:prasannavenkadesh.github.io,2020-12-06:/blog/notes-from-clean-arch.html</id><summary type="html">&lt;p&gt;These notes are from Clean Architecture book by Robert C.Martin (Uncle Bob) for my self-reference and will be updated as I progress through the chapters.&lt;/p&gt;
&lt;h3&gt;Part 1 - Introduction&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Both Architecture and Design points to same things in software development (Low-level and high-level details).&lt;/li&gt;
&lt;li&gt;The goal of Architecture is to …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;These notes are from Clean Architecture book by Robert C.Martin (Uncle Bob) for my self-reference and will be updated as I progress through the chapters.&lt;/p&gt;
&lt;h3&gt;Part 1 - Introduction&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Both Architecture and Design points to same things in software development (Low-level and high-level details).&lt;/li&gt;
&lt;li&gt;The goal of Architecture is to minimize the amount of human resource required to build and maintin the required system in the long run.&lt;/li&gt;
&lt;li&gt;Tale of 2 Values&lt;/li&gt;
&lt;li&gt;Behaviour: A software program must satisfy the functional requirements.&lt;ul&gt;
&lt;li&gt;Architecture: A software system must be in a good shape. Easy to extend for new requirements without starting from scratch.&lt;/li&gt;
&lt;li&gt;Both must be satisfied, but if Architecture is compromised, it will become too hard to add new features and proceed further.&lt;/li&gt;
&lt;li&gt;Business managers always go with Behaviour beacuse of the estimate they have projected.&lt;/li&gt;
&lt;li&gt;Developers must fight for a good design and architecture.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To effectively segregate tasks author recommends to use Eisenhower Matrix&lt;/li&gt;
&lt;li&gt;urgent &amp;amp; important (top priority)&lt;ul&gt;
&lt;li&gt;urgent &amp;amp; not important (delegate)&lt;/li&gt;
&lt;li&gt;not urgent but important (schedule)&lt;/li&gt;
&lt;li&gt;not urgent and not important (avoid)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Part 2 - Programming Paradigms&lt;/h3&gt;
&lt;p&gt;Programming Paradigms are considered the building blocks (or) bricks of code.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Different paradigm exists.&lt;/li&gt;
&lt;li&gt;structured&lt;ul&gt;
&lt;li&gt;object oriented&lt;/li&gt;
&lt;li&gt;functional&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Each paradigm enforces a particular discipline on the code. Djisktra's paper "Goto considered harmful"&lt;/li&gt;
&lt;li&gt;Structured programming imposes discipline on direct transfer of control.&lt;ul&gt;
&lt;li&gt;Object oriented programming imposes discipline on indirect transfer of control.&lt;/li&gt;
&lt;li&gt;Functional programming imposes discpline upon asignment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;These paradigms restrict the way we code in one way or the other enforcing a particular discipline.&lt;/li&gt;
&lt;li&gt;What does these paradigms have go to do with Architecture or design? Examples&lt;/li&gt;
&lt;li&gt;Polymorphism as the mechanism to cross architectural boundaries.&lt;ul&gt;
&lt;li&gt;functional programming to impose discipline on the location of and access of data.&lt;/li&gt;
&lt;li&gt;structured programming as the algorithmic foundation of our modules.&lt;/li&gt;
&lt;li&gt;In short, function, separation of components and data management.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Decompose functional requirements into atomic verifiable units (functions) and verify their behaviour with unit tests&lt;/li&gt;
&lt;li&gt;Polymorphism paves way for a plugin architecture and depedency inversion for source code dependency over flow of control.&lt;/li&gt;
&lt;li&gt;Author celebrates the power the dependency inversion that polymorphism of OO approach provides.&lt;/li&gt;
&lt;li&gt;A scalable application requires concurrency. The immutable property of functional paradigm (pure functions) helps us achieve great concurrency.&lt;/li&gt;
&lt;li&gt;A well structured application would be segregated into components that mutate variables and components that don't.&lt;/li&gt;
&lt;li&gt;We could take event sourcing model where we don't store and update the state for every transaction, instead we could log the transactions and derive state from it at any given time. But that assumes infinite storage and infinite processing power.&lt;/li&gt;
&lt;li&gt;To summarize, each paradigm restrict some aspect of the way we write code. For the last half-century we have learned what not to do.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Part 3 - Design Principles&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Good software systems begin with clean code.&lt;/li&gt;
&lt;li&gt;On one hand, if the bricks aren't well made, the architecture of the system doesn't matter.&lt;/li&gt;
&lt;li&gt;On the other hand, you can make a mess with a well made bricks. This is where design princples comes in.&lt;/li&gt;
&lt;li&gt;The design principles tell us how to arrange our functions, modules and data structures and how they should be interconnected.&lt;/li&gt;
&lt;li&gt;SOLID is one such design principle.&lt;/li&gt;
&lt;li&gt;The goal of this principles is to create mid-level structures that&lt;/li&gt;
&lt;li&gt;tolerate change,&lt;ul&gt;
&lt;li&gt;are easy to understand and&lt;/li&gt;
&lt;li&gt;are the basis of components that can be used in many software systems.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;SRP (Single Responsibility Principle)&lt;ul&gt;
&lt;li&gt;a module should be responsible to one, and only, one actor.&lt;/li&gt;
&lt;li&gt;OCP (Open-Closed Principle)&lt;/li&gt;
&lt;li&gt;LSP (Liskov Substitution Principle)&lt;/li&gt;
&lt;li&gt;ISP (Interface Segregation Principle)&lt;/li&gt;
&lt;li&gt;DIP (Dependency Inversion Principle)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="Notes"></category><category term="notes"></category><category term="architecture"></category><category term="books"></category><category term="code"></category><category term="design"></category><category term="software"></category></entry></feed>