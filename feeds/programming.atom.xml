<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Towards Freedom</title><link href="https://prasannavenkadesh.github.io/blog/" rel="alternate"></link><link href="https://prasannavenkadesh.github.io/blog/feeds/programming.atom.xml" rel="self"></link><id>https://prasannavenkadesh.github.io/blog/</id><updated>2016-07-08T00:00:00+05:30</updated><entry><title>P2P File &amp; URL Sharing App on LAN</title><link href="https://prasannavenkadesh.github.io/blog/working-on-p2p-file-url-sharing-app.html" rel="alternate"></link><updated>2016-07-08T00:00:00+05:30</updated><author><name>Prasanna Venkadesh</name></author><id>tag:prasannavenkadesh.github.io,2016-07-08:blog/working-on-p2p-file-url-sharing-app.html</id><summary type="html">&lt;p&gt;For the past 1 week, I have been working on a peer-to-peer File and URL sharing app and I have named it as &lt;strong&gt;Transceiver&lt;/strong&gt; (the ability to transmit and receive data). I would like to log the progress of what I have done so far.&lt;/p&gt;
&lt;p&gt;There are various reasons, why I am writing this application.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;I wanted to try and learn how to build cross platform Desktop applications using &lt;a href="http://electron.atom.io/"&gt;electron&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;I wanted to write a p2p application, since I have been exploring p2p and mesh networking quite often.&lt;/li&gt;
&lt;li&gt;Last thing, I needed this application.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Whenever I attend meetups and I wanted to share some URLs that I have bookmarked to others, we do this by using some service that runs on Internet. It could be IRC or any Instant Messengers. Sometimes we have even tried using Pidgin + Bonjour (Avahi for GNU/Linux) and that have worked well too. But we have never succeeded file transfer through Pidgin + Bonjour.&lt;/p&gt;
&lt;p&gt;Following is a GIF of what have been done so far.&lt;/p&gt;
&lt;p&gt;&lt;img style="border: 1px solid black" src="images/transceiver.gif"&gt;&lt;/img&gt;&lt;/p&gt;
&lt;p&gt;First thing, it doesn't make sense to send URL links or Files or any data through Internet to a person who is sitting next to me or in the same hall, connected to the same network. The data doesn't need to leave the network in first place and also you don't need to expose to all those centralized services out there.&lt;/p&gt;
&lt;p&gt;Second thing, even in such a WLAN (or) LAN, there should be no central server / single point of failure. People should be able to form ad-hoc networks and should be able to communicate. In this sense, this application is serverless and peer-to-peer such that it doesn't need any central server (or) signalling server (like how they have in torrent trackers or webRTC peer connection) to connect to each other.&lt;/p&gt;
&lt;p&gt;Third thing, it has to be a Free Software. There already exists few of them like D-LAN (Distributed File Sharing on LAN), Lan Messenger, etc., I am just stacking up mine to the list.&lt;/p&gt;
&lt;p&gt;I use,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.zeroconf.org/"&gt;Zeroconf&lt;/a&gt; (also known as Bonjour or Avahi in GNU/Linux) for automatically registering and discovering peers on the same network.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://socket.io/"&gt;Socket.io&lt;/a&gt; for end to end socket connection. (I could still make use of socketio to upgrade the connection to webRTC).&lt;/li&gt;
&lt;li&gt;Electron + nodejs as a cross-platform framework.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;An instance of this application can act as both server and client at the same time, thus can listen for incoming data and also it can send data to other peers on the network. Since the peers are discovered through zerconf, their identities are exposed to everyone on the network using this app and thus we are able to eliminate central signalling server here.&lt;/p&gt;
&lt;p&gt;For now the text / URL sharing is complete. I am yet to work on the File transfer part. I am releasing this work under Free Software license (GPL v3) and the source code is hosted on &lt;a href="https://gitlab.com/prashere/transceiver/"&gt;gitlab here&lt;/a&gt;.&lt;/p&gt;</summary><category term="code"></category><category term="free software"></category><category term="networks"></category><category term="tech"></category></entry><entry><title>Cross Compilation in Go</title><link href="https://prasannavenkadesh.github.io/blog/go-cross-compilation.html" rel="alternate"></link><updated>2016-06-24T00:00:00+05:30</updated><author><name>Prasanna Venkadesh</name></author><id>tag:prasannavenkadesh.github.io,2016-06-24:blog/go-cross-compilation.html</id><summary type="html">&lt;p&gt;Recently I have started to explore the Go programming language or golang in short. Go is a compiled language which can produce standalone binaries for the go programs, which means the receiver of this binary need not have go compiler and the libraries that this program is dependent installed on their machine, instead they can just run the binary and the program will be executed.&lt;/p&gt;
&lt;p&gt;This is also the same case with C and C++. If you have used GCC (GNU Compiler Collection) then you could have come across something called cross-compilation in gcc. Compilation means converting from source code to binary, while cross compilation means producing binaries that can be used on other target architectures too.&lt;/p&gt;
&lt;p&gt;For example, I am writing code in my laptop which is running Linux kernel and the cpu &amp;amp; operating system architectures are 64-bit (often represented as amd64 or x86_64). When I compile this source code on my laptop, I will get a binary. I can execute this binary and can also distribute. But the only constraint is this binary is build for 64bit architecture and linux based machines only. Therefore if someone who runs 32bit or ARM based architectures even with Linux kernel, they cannot use this binary.&lt;/p&gt;
&lt;p&gt;In order to overcome this, gcc allows developers to do cross compilation. Similarly go compiler also has this feature inbuilt. Here is how we do it&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;env GOOS=linux GOARCH=arm go build somefile.go
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In the above command, I am setting values for two environment variables GOOS and GOARCH respectively where GOOS is the name of the kernel used in target operating system and GOARCH is the name of the cpu architecture used in the target computer hardware. Succeeding that is the go command to build binary from the source code &lt;code&gt;somefile.go&lt;/code&gt;. It will take few seconds to build the binary, once that is done now the binary can be used to execute the program in the target machine.&lt;/p&gt;
&lt;p&gt;To know the valid and available GOOS and GOARCH values that go accepts, &lt;a href="https://golang.org/doc/install/source#environment"&gt;go here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Note: Producing binaries and distributing them is very good from users usability point of view. It will be convinient for users to just double click on something to see it work (in fact that's how most of them were training through Microsoft Windows). As a free software activist, I appeal that we should also consider the users freedom point of view and give them links to access the source code of the same program that they use in their computer in the binary. The users have the right to know what is being executed in their machines.&lt;/p&gt;</summary><category term="tech"></category><category term="code"></category></entry></feed>